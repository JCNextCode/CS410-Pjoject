160
Chapter 8
Search Engine Implementation
As long as the lexicon has a pointer to the beginning of a compressed integer, we
can easily support random access decoding. We also have the property that small
numbers take less space, while larger numbers take up more space. The next two
compression methods are built on the concept of unary encoding.
Gamma. To encode a number with γ -encoding, first simply write the number in
binary. Let k be the number of bits in your binary string. Then, prepend k − 1 zeros
to the binary number:
1 → 1
2 → 010
3 → 011
4 → 00100
5 → 00101
19 → 000010011
47 → 00000101111
Todecode, readandcountk zerosuntilyouhitaone.Readtheoneandadditional
k bits in binary. Note that all γ codes will have an odd number of bits.
Delta. In short, δ-encoding is γ -encoding a number and then γ -encoding the
unary prefix (including the one):
1 → 1 → 1
2 → 010 → 0100
3 → 011 → 0101
4 → 00100 → 01100
5 → 00101 → 01101
19 → 000010011 → 001010011
47 → 00000101111 → 0011001111
To decode, decode the γ code at your start position to get an integer k. Write
a one, and then read the next k + 1 bits in binary (including the one you wrote).
As you can see, the δ compression at first starts off to have more bits than the
γ encoding, but eventually becomes more efficient as the numbers get larger. It
probably depends on the particular dataset (the distribution of integers) as to which
compressionmethodwouldbebetterintermsofcompressionratio.Acompression
ratio is simply the uncompressed size divided by the compressed size. Thus, a
compression ratio of 3 is better (in that the compressed files are smaller) than a
compression ratio of 2.
8.5.2
Block compression
While bitwise encoding can achieve a very high compression ratio due to its fine-
grained distribution model, its downside is the amount of processing that is re-
