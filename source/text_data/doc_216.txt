196
Chapter 10
Web Search
Key, Value
Input
Map(K, V)
Key, Value
Output
Key, Value
…
Key, Value
Map(K, V)
Reduce(K, V[])
MapReduce internal collection/sorting
Key, Value
Key, Value
…
Key, Value
Map(K, V)
Key, Value
Key, Value
…
Key, Value
Key, Value
Key, Value
Figure 10.2
Computation flow of MapReduce.
MapReduce framework. With such a framework, the input data can be partitioned
into multiple parts which are processed in parallel first by map, and then processed
again in parallel once we reach the reduce stage.
Figure 10.3 shows an example of word counting. The input is files containing
tokenized words and the output that we want to generate is the number of occur-
rences of each word. This kind of counting would be useful to assess the popularity
of a word in a large collection or achieving an effect of IDF weighting for search. So,
how can we solve this problem? One natural thought is that this task can be done
in parallel by simply counting different parts of the file in parallel and combining
all the counts. That’s precisely the idea of what we can do with MapReduce: we can
parallelize lines in this input file. More specifically, we can assume the input to
each map function is a (key, value) pair that represents the line number and the
string on that line.
The first line is the pair (1, Hello World Bye World). This pair will be sent to a map
function that counts the words in this line. In this case, there are only four words
and each word gets a count of one. The map pseudocode shown at the bottom of
the figure is quite simple. It simply needs to iterate over all the words in this line,
