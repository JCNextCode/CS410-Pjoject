156
Chapter 8
Search Engine Implementation
Algorithm 8.2
Document-at-a-time Ranking
context = {}
// maps a document to a list of matching terms
for w ∈ q do
for d, count ∈ Idx.fetch docs(w) do
context[d].append(count)
end for
end for
priority queue = {}
// low score is treated as high priority
for d, term counts ∈ context do
score = 0
for count ∈ term counts do
score = score + score term(count)
end for
priority queue.push(d, score)
if priority queue.size() > k then
priority queue.pop()
// removes lowest score so far
end if
end for
Return sorted documents from priority queue
Filters can be as complex as desired, since a filter is essentially just a Boolean
function that takes a document and returns whether or not it should be returned
in the list of scored documents. The filtering function can then be an optional
parameter to the scoring function which has access to the document metadata
store (usually a database) and a forward index (in order to filter documents that
contain certain terms).
8.3.4
Index Sharding
Index sharding is the concept of keeping more than one inverted index for a partic-
ular search engine. This is easily achieved by stopping the postings chunk merging
process when the number of chunks is equal to the number of desired shards. All
the same data is stored as one final chunk, but it’s just broken down into several
pieces.
But why would we want multiple inverted index chunks? Consider when we
have the number of shards equal to the number of threads (or cluster nodes) in
our search system. You can probably imagine an algorithm where each thread
searches for matching terms in its respective shard, and the final search results
