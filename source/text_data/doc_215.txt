10.2 Web Indexing
195
Application
GFS client
GFS chunkserver
Linux ﬁle system
chunk 2ef()
Data messages
Control messages
Legend:
/foo/bar
GFS master
File namespace
Instructions to chunkserver
(ﬁle name, chunk index)
(chunk handle,
chunk locations)
(chunk handle, byte range)
Chunk data
Data transfer is directly
between applications
and chunkservers
Simple centralized
management
Fixed chunk size
(64 MB)
Chunk is replicated
to ensure reliability
Chunkserver state
GFS chunkserver
Linux ﬁle system
Figure 10.1
Illustration of Google File System. (Based on Ghemawat et al. [2003])
this framework hides low level features from the programmer. As a result, the pro-
grammer can make minimum effort to create an application that can be run on a
large cluster in parallel. Some of the low-level details hidden in the framework are
communications, load balancing, and task execution. Fault tolerance is also built
in; if one server goes down, some tasks may not be finished. Here, the MapReduce
mechanism would know that the task has not been completed and would automat-
ically dispatch the task on other servers that can do the job. Again, the programmer
doesn’t have to worry about this.
In MapReduce, the input data are separated into a number of (key, value) pairs.
What exactly the value is will depend on the data. Each pair will be then sent to
a map function which the programmer writes. The map function will then process
these (key, value) pairs and generate a number of other (key, value) pairs. Of course,
the new key is usually different from the old key that’s given to map as input. All the
outputs of all the calls to map are collected and sorted based on the key. The result
is that all the values that are associated with the same key will be grouped together.
For each unique key we now have a set of values that are attached to this key.
This is the data that is sent to the reduce function. Each reduce instance will
handle a different key. This function processes its input, which is a key and a
set of values, to produce another set of (key, value) pairs as the output. This is
the general framework of MapReduce. Now, the programmer only needs to write
the map function and the reduce function. Everything else is taken care of by the
